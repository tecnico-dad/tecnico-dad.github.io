<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
    <link href="../_css/labs-sd.css" rel="stylesheet" type="text/css"/>
    <link href="../_prettify/prettify.css" rel="stylesheet" type="text/css"/>
    <script src="../_prettify/prettify.js" type="text/javascript"></script>
    <title>Tratamento de erros com gRPC e testes de integração com JUnit</title>

    <style type="text/css">
        body {
            padding-left: 1em;
            padding-right: 1em;
        }

        .underlined {
            text-decoration: underline !important;
        }
    </style>
</head>

<body onload="prettyPrint()">
<div class="contexto">
    <p><a href="../index.html">Labs SD</a> &gt;</p>
</div>
<div class="titulo" id="1">
    <h1>Tratamento de erros com gRPC e testes de integração com JUnit</h1>
</div>
<div class="objectivos">
    <h2>Objetivos da semana</h2>
    <ul>
        <li>Analisar duas abordagens para tratar erros com gRPC</li>
        <li>Aprender a escrever testes de integração utilizando JUnit 5</li>
    </ul>
</div>
<div class="corpo" style="padding-right: 2em">
    <!--
    <h2 id="conteudos">Materiais de apoio à aula</h2>
    <ul>
        <li><a href="https://grpc.io/docs/tutorials/basic/java.html">Tutorial de gRPC para Java</a></li>
        <li><a href="https://developers.google.com/protocol-buffers/docs/overview">Documentação de <i>Protocol
            Buffers</i></a></li>
        <li><a href="https://grpc.io/grpc-java/javadoc/index.html">API de gRPC para Java</a></li>
    </ul>
    <br/>
    -->

    <br>
    <h2>Tratamento de erros com gRPC</h2>
    <p>Após invocação de um procedimento remoto com gRPC, a chamada pode ter sucesso ou falhar, sendo enviado para o
        cliente um código de erro (ou <i>error status code</i>) neste último caso. gRPC é uma framework agnóstica
        relativamente à linguagem de programação que se utiliza, pelo que o recurso a um conjunto limitado de códigos de
        erro é a forma base de tratar situações em que a invocação remota falha.</p>
    <p>De acordo com a <a href="https://grpc.io/docs/guides/error/">documentação oficial</a>, existem três categorias de
        códigos de erro suportadas por todas as bibliotecas cliente/servidor gRPC e independentes do formato de dados:
    </p>
    <ul id="common_errors">
        <li><b>Erros gerais</b>, como o <span class="underlined">cancelamento do pedido por parte do cliente</span> ou a
            <span class="underlined">invocação de um método que não está implementado no servidor</span>;
        </li>
        <li><b>Falhas na rede</b>, como a situação em que <span class="underlined">apenas parte dos dados é transmitida antes de a ligação terminar</span>;
        </li>
        <li><b>Erros de protocolo</b>, como <span class="underlined">acesso não autenticado</span> ou <span
                class="underlined">violação do protocolo de fluxo de controlo</span>.
        </li>
    </ul>
    <p>Este modelo, embora seja suficiente em algumas situações, não permite comunicar informações mais detalhadas
        acerca
        do erro em causa. Foi criado, por isso, um <a href="https://cloud.google.com/apis/design/errors#error_model">modelo
            de erros mais rico</a> que, além de um <b><a
                href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto">conjunto mais
            vasto de
            códigos de erro</a></b>, permite incluir detalhes que podem ser relevantes para o cliente conseguir
        recuperar do
        erro,
        como <b id="richer_model_text">uma descrição textual do erro</b> e/ou <b
                id="richer_model_metadata">metadados</b>. Nem todas as bibliotecas cliente/servidor gRPC
        suportam este modelo, mas Java (a que usaremos) suporta.</p>

    <br>
    <h3>Como retornar um erro?</h3>
    <p>Tome como exemplo a implementação do método <tt>currentBoard</tt> do <a href="../05-rpc">laboratório anterior</a>.
    </p>
    <pre class="prettyprint lang-java">
public void currentBoard(CurrentBoardRequest request, StreamObserver&lt;CurrentBoardResponse&gt; responseObserver) {
    CurrentBoardResponse response = CurrentBoardResponse.newBuilder().setBoard(ttt.currentBoard()).build();
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}</pre>
    <p>Em caso de erro, é importante notificar o cliente de que a execução remota falhou, para que consiga recuperar
        (por exemplo, através da repetição da invocação). Esse estado de erro pode ser induzido, por exemplo, por uma
        falha na conexão entre cliente e servidor (como descrito
        <a href="#common_errors">anteriormente</a>) ou introduzido pelo próprio programador, para acautelar violações do
        domínio da aplicação. A validação de argumentos é um exemplo clássico.</p>
    <p>No caso de Java, é possível explicitar que a chamada remota falhou invocando
        <tt>responseObserver.onError(...)</tt> quando necessário. Este método recebe um <tt>Throwable</tt>, sendo
        qualquer exceção em Java uma subclasse desta. Esta invocação altera o fluxo de execução do programa. Quer isto
        dizer que, num determinado fluxo, <tt>onCompleted</tt> e <tt>onError</tt> só podem ser invocadas uma vez e, se
        forem, devem ser as últimas (não podendo, por isso, ser executadas em conjunto). A título de exemplo, e
        considerando a guarda <tt>condition</tt>, deve ter-se algo como</p>
    <pre class="prettyprint lang-java">
...
if (condition) {
    ...
    responseObserver.onError(...);
} else {
    ...
    responseObserver.onNext(...);
    responseObserver.onCompleted();
}
...
    </pre>
    <p>No entanto, há que ter em conta que as exceções passadas como argumento a <tt>onError</tt> são automaticamente
        encapsuladas dentro de <tt>StatusRuntimeException</tt> ou <tt>StatusException</tt>, perdendo informação
        relevante sobre a sua origem (uma
        vez que esta pertence exclusivamente ao domínio do servidor). Assim sendo, as únicas exceções que o cliente
        poderá
        receber do seu lado são do tipo <tt>StatusRuntimeException</tt> (que herda de <tt>RuntimeException</tt>) ou <tt>StatusException</tt>
        (que herda de <tt>Exception</tt>).</p>

    <p>No modelo que estamos a considerar, gRPC oferece uma estrutura que permite modelar o estado de uma
        invocação remota, <tt>Status</tt> (cuja implementação em Java pode ser consultada
        <a href="https://github.com/grpc/grpc-java/blob/master/api/src/main/java/io/grpc/Status.java">aqui</a>). Em
        Java, esta classe define, para cada estado, um código e uma descrição do estado, modelando também os estados de
        erro de que
        temos vindo a falar. Um exemplo é o estado <tt>INVALID_ARGUMENT</tt>, utilizado para representar o estado de
        erro em que se incorre quando o cliente especifica um argumento inválido. A grande vantagem desta classe é que
        possui um método que mapeia automaticamente um <tt>Status</tt> numa exceção, pronta a ser passada ao método <tt>onError</tt>.
    </p>
    <p>Por exemplo, para que o cliente receba uma <tt>StatusRuntimeException</tt> (análogo para <tt>StatusException</tt>)
        ao especificar um argumento inválido,
        o servidor pode invocar</p>
    <pre class="prettyprint lang-java">
...
responseObserver.onError(Status.INVALID_ARGUMENT.asRuntimeException());
...
    </pre>

    <br>
    <h3>Como adicionar informação ao erro?</h3>
    <h4>Descrição textual</h4>
    <p>Como discutido anteriormente, é ainda possível passar mais informação ao cliente acerca do erro em causa. Por
        exemplo, para passar uma descrição textual do erro (atribuída à variável <tt>desc</tt>), o servidor pode invocar
    </p>
    <pre class="prettyprint lang-java">
...
responseObserver.onError(Status.INVALID_ARGUMENT.withDescription(desc).asRuntimeException());
...
    </pre>

    <br>
    <h3>Como captar o erro no cliente?</h3>
    <p>Para captar o erro do lado do cliente, basta introduzir um bloco <tt>try-catch</tt> para uma exceção do tipo <tt>StatusRuntimeException</tt>,
        que oferece o método <tt>getStatus</tt>, que devolve a instância de <tt>Status</tt> previamente encapsulada,
        como explicado. Supondo, então, que existe, do lado do cliente, um stub com nome <tt>stub</tt>, imprimir o
        código de erro é facil</p>

    <pre class="prettyprint lang-java">
...
try {
  stub.currentBoard(currentBoardRequest);

} catch (StatusRuntimeException e) {
  Status status = e.getStatus();
  System.out.println(status.getDescription());
}
...
    </pre>

    <p>Atente-se que a descrição que se obtém ao invocar <tt>status.getDescription()</tt> é igual à descrição
        <tt>desc</tt> que foi previamente passada no servidor (em <tt>Status.INVALID_ARGUMENT.withDescription(desc).asRuntimeException()</tt>).
    </p>

    <!--
    <br>
    <h4>Metadados</h4>
    <p>A passagem de metadados é igualmente possível, mas mais complexa. Todas as mensagens trocadas com gRPC necessitam
        de um marshaller, ou seja de uma entidade que seja capaz de transformar a representação um objeto num formato
        adequado para a sua transmissão, e vice-versa. Em particular, se quisermos enviar um metadado,
        necessitamos de um marshaller binário para o mesmo, para que a framework saiba como convertê-lo adequadamente de
        e para um <tt>byte[]</tt>.</p>
    <p>Vamos, a título de exemplo, enviar um metadado que seja o próprio <tt>CurrentBoardRequest</tt> recebido. Para
        tal, vamos utilizar o <tt>BinaryMarshaller</tt> que a framework já oferece (disponível em <tt>Metadata.BINARY_BYTE_MARSHALLER</tt>).<b>Esta
            é a entidade que converte o nosso objeto em <tt>byte[]</tt>e vice-versa</b>.Comecemos por criar a instância
        que armazena os metadados.</p>
    <pre class="prettyprint lang-java">
Metadata trailers = new Metadata();
    </pre>
    <p>Esta instância funciona como uma base de dados de pares chave-valor, ao estilo <tt>HashMap</tt>, em que
        <b>cada</b> chave corresponde ao nome do metadado e o <b>valor</b> ao conteúdo do metadado em si. A chave é
        sempre uma instância de <tt>Metadata.Key&lt;T&gt;</tt>, em que <tt>T</tt> designa o tipo do nosso metadado. Este
        tipo tem de ter um marshaller associado, pelo motivo discutido acima. Na linha abaixo, vamos criar uma
        <b>chave</b> com
        nome <tt>keyName</tt> cujo metadado será do do tipo <tt>byte[]</tt> (uma vez que utilizamos um <tt>BinaryMarshaller</tt>).
    </p>

    <pre class="prettyprint lang-java">
Metadata.Key&lt;byte[]&gt; key = Metadata.Key.of("keyName", Metadata.BINARY_BYTE_MARSHALLER);
    </pre>
    <br>
    <p><b>NOTA:</b> Num outro cenário, poderíamos, por exemplo, necessitar de um metadado que fosse do tipo
        <tt>String</tt>, e isso
        seria
        possível uma vez que já existe um marshaller específico para <tt>String</tt> (disponível em <tt>Metadata.ASCII_STRING_MARSHALLER</tt>).
        Analogamente, o código seria muito semelhante.</p>
    <pre class="prettyprint lang-java">
Metadata.Key&lt;String&gt; key = Metadata.Key.of("keyName", Metadata.ASCII_STRING_MARSHALLER);
    </pre>
    <br>
    <p>Retomando a explicação para o marshaller binário, vamos, agora, construir o nosso <b>valor</b>. Como explicado,
        terá de ser do tipo <tt>byte[]</tt>. Suponhamos, neste caso, </p>
    <br>
    -->
    <br>
    <h2>Testes de integração com JUnit</h2>
    <p>Os testes de integração (integration tests) verificam o comportamento de vários componentes do sistema.<br>Por
        outras palavras, verificam se os componentes se integram bem uns com os outros.</p>

    <p><a href="https://junit.org/junit5/docs/current/user-guide/">JUnit</a> é uma biblioteca Java para escrever testes
        ao código. Também pode ser usada para fazer testes de integração.</p>

    <p>Os testes de integração com JUnit 5 usam as mesmas anotações para definir qual o papel dos métodos:</p>
    <ul>
        <li>Os métodos anotados com @Test são testes individuais;</li>
        <li><tt>@BeforeEach</tt> e <tt>@AfterEach</tt> são executados antes e depois de cada teste, respetivamente;</li>
        <li><tt>@BeforeAll</tt> e <tt>@AfterAll</tt> são executados apenas uma vez para o conjunto de testes da classe.
        </li>
    </ul>

    <p>Os testes de integração utilizam funções de <a
            href="https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html">assert</a> para
        verificar o resultado esperado de cada teste.<br>A forma standard é <tt>assertEquals(expected, actual)</tt> (em
        que <tt>expected</tt> é o valor esperado e <tt>actual</tt> é o valor que resultou da execução).</p>
    <p>No entanto, muitos outros existem (com nome sugestivo da funcionalidade):</p>
    <ul>
        <li><tt>assertArrayEquals</tt></li>
        <li><tt>assertFalse</tt></li>
        <li><tt>assertNull</tt></li>
        <li><tt>assertTimeout</tt></li>
        <li>...</li>
    </ul>

    <br>
    <p>Uma classe de testes de integração tem a seguinte estrutura:</p>
    <pre class="prettyprint lang-java">
package example.it;

import org.junit.*;
import static org.junit.Assert.*;

/** Integration test suite */
public class ExampleIT {

    // static members


    // one-time initialization and clean-up
    @BeforeAll
    public static void oneTimeSetUp() {
        // runs once before all tests in the suite
    }

    @AfterAll
    public static void oneTimeTearDown() {
        // runs once after all tests in the suite
    }

    // members


    // initialization and clean-up for each test
    @BeforeEach
    public void setUp() {
        // runs before each test
    }

    @AfterEach
    public void tearDown() {
        // runs after each test
    }

    // tests
    @Test
    public void testSomething() {
        // do something ...

        // assertEquals(expected, actual);
        // if the assert fails, the test fails
    }
}
    </pre>

    <br>
    <p>Por convenção, as classes de testes de integração terminam com (<tt>IT</tt>). Devem ser também arrumadas na pasta
        <tt>src/test/java</tt> do projeto.<br>O Maven executa os testes de integração na fase <b>verify</b> do ciclo de
        vida.</p>
    <p>Antes disso, é necessário configurar o <i>plug-in</i> <a
            href="https://maven.apache.org/surefire/maven-failsafe-plugin/">Failsafe</a> da forma ilustrada abaixo:</p>
    <pre class="prettyprint lang-xml">
&lt;plugin&gt;
    &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.19.1&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;integration-test&lt;/goal&gt;
                &lt;goal&gt;verify&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</pre>

    <br>
    <p>Os exemplos seguintes mostram como correr os testes de integração e como controlar quais os testes a
        executar.</p>
    <pre class="prettyprint lang-sh">
// to compile and execute all integration tests
$ mvn verify

// to execute only a specific test class
$ mvn verify -Dit.test=PingIT

// to execute only a specific test
$ mvn verify -Dit.test=PingIT#testPing

// you can also use wildcards (the example below will match classes starting with P)
$ mvn verify -Dit.test=P*

// to skip integration tests
$ mvn install -Dit.test.skip=true
    </pre>
    <br/>

    <!--ul>
        <li><a href="https://github.com/tecnico-distsys/example_grpc">gRPC Hello World <img src="../_img/github.png" alt="GitHub" height="16"></a><br />
            Siga as instruções dos ficheiros <tt>README.md</tt> para compilar e executar o exemplo.</li>
    </ul-->
    <p class="exercicios"></p>
    <h2 id="guiao">Exercícios a resolver até ao fim da aula</h2>

    <h3>Tratamento de erros com gRPC</h3>
    <p>Utilizaremos como ponto de partida uma versão modificada de parte do esqueleto do projeto. Nesta versão, o método
        de controlo <tt>ctrl_ping</tt>
        retorna a mensagem que recebeu como argumento depois de a validar.</p>

    <ol type="I">
        <li>Extraia a versão modificada de parte do esqueleto do projeto.
            <ol type="1">
                <li>Faça <b><i>Clone</i></b> ou <b><i>Download</i></b> do <a href="exercise_error-test-grpc.zip">código fonte de parte do
                    esqueleto <!--<img alt="GitHub" height="16" src="../_img/github.png"/>--></a>.
                </li>
                <li>Analise o código de forma a compreender a implementação.<br>
                    Comece por entender a estrutura das mensagens trocadas (no módulo <tt>silo-contract</tt>), passando,
                    depois, para o módulo <tt>silo-server</tt> e, por fim, para o módulo <tt>silo-client</tt>.
                </li>
                <li>Compile o código executando <tt>mvn compile</tt> na raiz do projeto.</li>
                <li>Lance o servidor, executando <tt>mvn exec:java</tt> no módulo <tt>silo-server</tt>.</li>
                <li>Lance um cliente, executando <tt>mvn exec:java</tt> no módulo <tt>silo-client</tt>.</li>
                <li>Compreenda a interação que foi definida entre cliente e servidor para efeitos deste
                    exercício.
                    <ol type="a">
                        <li>A aplicação cliente lê do <tt>stdin</tt> a mensagem a enviar ao servidor e imprime a
                            resposta do servidor (ou a mensagem de erro, se for o caso).<br/><br/>
                        </li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>Altere o módulo <tt>silo-server</tt>, de forma a que a mensagem recebida na chamada <tt>ctrl_ping</tt> não
            seja vazia e tenha um comprimento em caracteres compreendido no intervalo <tt>[2, 10]</tt>.
            <ol type="1">
                <li>Comece por criar duas exceções no domínio do <tt>Silo</tt>, em que cada exceção representa a
                    violação de uma das propriedades desejadas. Utilize nomes sugestivos.
                </li>
                <li>Implemente a validação da mensagem no método <tt>handleCtrlPing</tt> (definido em <tt>Silo.java</tt>),
                    que deverá passar a lançar as novas exceções.
                </li>
                <li>Ajuste o método <tt>ctrlPing</tt> definido em <tt>SiloServiceImpl.java</tt> para acomodar as
                    alterações.
                    <ol type="a">
                        <li>Deve mapear as exceções do domínio da aplicação em códigos de erro, utilizando a técnica
                            descrita, incluindo a
                            descrição textual da exceção no erro que o servidor envia para o cliente.
                        </li>
                        <li>Recorde-se de que as chamadas a <tt>onCompleted</tt> e <tt>onError</tt> alteram o fluxo de
                            execução.<br><br>
                        </li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>Altere o módulo <tt>silo-client</tt>, de forma a que o cliente, aquando da invocação remota, seja capaz de
            captar a mensagem de erro corretamente.
            <ol 1 type="">
                <li>Deve modificar o código disponibilizado em <tt>SiloClientApp.java</tt> para refletir as alterações.
                </li>
                <li>Recorde-se de que o estado pode ser obtido, no cliente, invocando <tt>e.getStatus()</tt> (sendo <tt>e</tt>
                    do tipo <tt>StatusRuntimeException</tt>).<br><br>
                </li>
            </ol>
        </li>
        <li>Teste a sua solução.
            <ol type="1">
                <li>Comece por compilar o projeto, executando <tt>mvn clean compile</tt> na raiz.</li>
                <li>Lance o servidor, executando <tt>mvn exec:java</tt> no módulo <tt>silo-server</tt>.</li>
                <li>Lance um cliente, executando <tt>mvn exec:java</tt> no módulo <tt>silo-client</tt>.
                    <ol type="a">
                        <li>Teste o envio de várias mensagens. Em particular, procure testar os casos limites para as
                            propriedades apresentadas.
                        </li>
                    </ol>
                </li>
            </ol>
        </li>
    </ol>

    <br>
    <h3>Testes de integração com JUnit</h3>
    <p>O objetivo desta parte do exercício é escrever os testes de integração para testar a funcionalidade do método
        <tt>ctrl_ping</tt> utilizando JUnit 5.</p>

    <ol type="I">
        <li>No módulo <tt>silo-client</tt>, crie os testes para o método, utilizando a base teórica deste laboratório.
            <ol type="1">
                <li>Em <tt>src/test/java</tt> encontra a classe base para testes em <tt>BaseIT.java</tt>.</li>
                <li>Crie uma nova classe chamada <tt>CtrlPingIT</tt> que herda de <tt>BaseIT</tt>.<br>
                    Lembre-se de testar os casos fronteira associados às propriedades da mensagem que <tt>ctrl_ping</tt>
                    recebe.<br><br>
                </li>
            </ol>
        </li>
        <li>Na raiz do módulo, execute <tt>mvn verify</tt> para executar os testes.</li>
    </ol>

</div>
<hr/>
<div class="rodape">
    <p>&copy; Docentes de Sistemas Distribu&iacute;dos, <a href="http://www.dei.tecnico.ulisboa.pt/">Dep. Eng.
        Informática</a>, <a href="http://www.ist.eu">Técnico Lisboa</a>
        <br/>
    </p>
</div>
</body>
</html>
