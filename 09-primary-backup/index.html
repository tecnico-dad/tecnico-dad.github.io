<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <link rel="stylesheet" type="text/css" href="../_css/labs-sd.css">

    <link href="../_prettify/prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="../_prettify/prettify.js"></script>

    <title>Projeto ECar - parte 2</title>
</head>

<body onload="prettyPrint()">

<div class="contexto">
    <p>
        <a href="../index.html">Labs SD</a> &gt;
    </p>
</div>

<div class="titulo" id="1">
    <h1>Projeto ECar - parte 2</h1>
</div>

<hr />
<h2>Exercício</h2>
<h3>Segunda parte do projeto</h3>

<p>
O objetivo deste exercício é replicar o ecar e implementar o mecanismo de provas de vida entre primário e secundário.
</p>

<p>
1) Replicar o servidor <tt>ecar-ws</tt>:
</p>
<ol type="a">
    <li>
    A forma mais simples de permitir múltiplas instâncias do mediador é
    parametrizar as propriedades de configuração com um número de instância, tal como se fez para o <tt>park-ws</tt>.
    </li>
    <li>
    Adicionar as seguintes definições ao <tt>pom.xml</tt> 
    (substituir CXX pelo identificador do grupo no POM principal):<br />
<pre class="prettyprint lang-xml">
    ...
    &lt;ws.i&gt;1&lt;/ws.i&gt;

    &lt;ws.host&gt;localhost&lt;/ws.host&gt;
    &lt;ws.port&gt;807${ws.i}&lt;/ws.port&gt;
    &lt;ws.url&gt;http://${ws.host}:${ws.port}/ecar-ws/endpoint&lt;/ws.url&gt;
   
    &lt;ws.name&gt;${ecar.ws.name}&lt;/ws.name&gt;
    ...
</pre>
    </li>
    <ul>
        <li>
        O porto do URL do serviço foi trocado para 8071, por omissão.
        </li>
        <li>
        O nome do serviço não inclui o número de instância
        porque o servidor secundário não se regista no UDDI.
        O secundário "não existe" para os clientes.
        </li>
    </ul>
    <li>
    Para lançar o servidor primário:
    </li>
    <ul>
        <li>
        <tt>mvn compile</tt>
        </li>
        <li>
        <tt>mvn exec:java</tt><br />
        Por omissão, será a instância 1, 
        que fica à escuta de pedidos no porto 8071 e 
        que se regista com o nome CXX_ECar.
        </li>
    </ul>
    <li>
    Para lançar o Mediador Secundário:
    </li>
    <ul>
        <li>
        <tt>mvn exec:java <b>-Dws.i=2</b></tt><br />
        A instância <b>2</b> fica à escuta de pedidos no porto 807<b>2</b> e não se regista no UDDI.<br />
        </li>
    </ul>
</ol>
<p>
Cada instância, ao arrancar, deve imprimir para a consola uma 
mensagem que indique se está a funcionar como primário ou
como secundário
</p>
<p>
A partir deste momento já existem duas instâncias do servidor a correr,
mas ambas vão ter estados diferentes, pelo que não são ainda réplicas.
A replicação de estado será tratada depois.
</p>

<p>
2) Pretende-se agora modificar o contrato WSDL do servidor para permitir uma operação unidireccional de prova de vida: <tt>imAlive</tt>.
</p>
<ol type="a">
    <li>
    Criar nova versão do WSDL. 
    Pretende-se manter a compatibilidade com as operações existentes,
    pelo que a modificação seguinte deve apenas <b>acrescentar</b>
    elementos e operações.
    </li>
    <li>
    Sem alterar as operações já definidas no WSDL, 
    adicionar uma nova operação <tt>imAlive</tt>.
    </li>
    <li>
    Fazer <tt>mvn generate-sources</tt>
    </li>
    <li>
    Implementar método <tt>imAlive()</tt> no servidor onde:
    </li>
    <ul>
        <li>
        Se for mediador primário, 
        retorna sem executar qualquer instrução.
        </li>
        <li>
        Se for mediador secundário, 
        guarda a data da hora da chegada dessa prova de vida 
        (<i>timestamp</i> do instante em que o método foi executado).
        </li>
    </ul>
    <li>
    Adicionar método <tt>imAlive()</tt> no ECarClient que executa a chamada do método sobre o <i>stub</i>.
    </li>
</ol>

<p>
3) Pretende-se agora criar uma classe <tt>LifeProof.java</tt> que faz o lançamento de provas de vida do servidor primário para secundário.
</p>
<ol type="a">
    <li>
    Para as provas de vida, será necessário ter uma atividade que se executa de forma independente.<br /> 
    Esta atividade pode estender a classe <i>TimerTask</i> do Java:
    </li>
    <ul>
        <!--li>
        <a href="thread.zip">thread
        <img src="../_img/zip.png" alt="ZIP"></a>
        - criação de novas tarefas<br />
        </li-->
        <li>
        <a href="timer.zip">timer
        <img src="../_img/zip.png" alt="ZIP"></a>
        - criação de novas tarefas temporizadas<br />
        </li>
    </ul>
    <li>
    <!--Uma vez escolhida <i>Thread</i> ou <i>TimerTask</i>,<br />-->
    Criar uma classe <tt>LifeProof.java</tt> 
    no <tt>ecar-ws</tt>.
    </li>
    <li>
    Implementar o método <tt>run</tt> da classe para que, se for o servidor primário:
    </li>
    <ul>
        <li>
        Cria um cliente que aponta para o servidor secundário<br />
        (através de convenção estabelecida ou argumento explícito
        - não usa UDDI porque se assume que 
        o primário conhece o secundário)
        </li>
        <li>    
        De 5 em 5 segundos (valor configurável) chama o 
        método <tt>imAlive()</tt> no servidor através do cliente
        </li>
    </ul>
    <li>
    Modificar a classe <tt>ECarApp</tt> de modo a lançar a classe <tt>LifeProof</tt> antes de ficar à escuta de pedidos.
    </li>
</ol>

<p>
<b>
Próximos passos:
</b>
</p>

<p>
4) Acrescentar à classe <tt>LifeProof.java</tt> o comportamento para o caso de ser o servidor secundário
</p>
<!--
, i.e.:
</p>
<ol> 
    - Detetar a falha do mediador principal por ausência de provas de vida recebidas
    - Substituir no UDDI o mediador primário pelo secundário
    - Passar o mediador secundário para "modo primário"
</ol>
-->

<p>
5) Modificar novamente o contrato WSDL para conter as 
operações auxiliares de atualização de estado do servidor secundário.<br />
Estas operações devem ser unidireccionais.
Exemplo:
</p>
<ul>
    <li><tt>
    void updateUser(...<!-- ShoppingResultView srv, String cartId, int updateId-->)
    </tt></li>
</ul>

<p>
6) Implementar a lógica de atualizações entre os dois servidor, tendo em atenção a execução de pedidos repetidos avaliando a idempotência das operações
</p>

<p>
7) Utilizar as invocações de operações com <i>timeout</i> para alterar o <tt>ECarClient</tt> de modo a 
garantir um <i>front-end</i> com a semântica no-máximo-uma-vez, tendo em atenção os vários tipos de exceções de comunicação.
Ou seja, tornar o cliente tolerante a faltas de
quebra de ligação TCP dos pedidos-respostas HTTP
</p>
<ul>
<li>
Os intervalos de tempo devem ser configuráveis
</li>
<li>
Apenas as operações principais
- i.e. aquelas que se destinam a ser chamadas dos clientes para o mediador -
necessitam de ser tolerantes a faltas.
Por outras palavras, as operações test... não necessitam de ser replicadas.
</li>
<li>
Mais informação sobre <a href="../01-tools/exceptions/index.html">tratamento de exceções</a> e 
sobre <a href="../05-ws/junit-it/ws-exceptions.html">exceções de Web Services</a>.
</li>
</ul>


<p>
<b>Continuação de bom trabalho!</b>
</p>


<p>
&nbsp;
</p>

</div>

<hr />


<div class="rodape">
<p>
&copy; Docentes de Sistemas Distribuídos,
<a href="http://www.dei.tecnico.ulisboa.pt/">Dep. Eng. Informática</a>,
<a href="http://www.ist.eu">Técnico Lisboa</a><br />
</p>
</div>

</body></html>
