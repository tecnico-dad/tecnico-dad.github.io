<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <link rel="stylesheet" type="text/css" href="../_css/labs-sd.css">

    <link href="../_prettify/prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="../_prettify/prettify.js"></script>

    <title>Web Services III</title>
</head>

<body onload="prettyPrint()">

<div class="contexto">
    <p>
        <a href="../index.html">Labs SD</a> &gt;
    </p>
</div>

<div class="titulo" id="1">
    <h1>Web Services III</h1>
</div>

<div class="objectivos">

    <h2>Objectivos</h2>
    <ul>
        <li>Configurar o limite de tempo de espera do cliente</li>
        <li>Invocar uma operação unidirecional <i>(one-way)</i></li>
        <li>Fazer chamadas assíncronas <i>(async)</i></li>
    </ul>
</div>

<div class="indice">
<p><b>Índice:</b></p>
<ul>
    <li><a href="#timeout">Limite de tempo</a></li>
    <li><a href="#oneway">Operações unidirecionais</a></li>
    <li><a href="#async">Operações assíncronas</a></li>
    <li><a href="#exercicio">Exercício</a></li>
</ul>
</div>

<div class="corpo">

<hr />

<h2 id="timeout">Limite de tempo</h2>
<img src="clock.png" height="60" />
<p>
O exemplo abaixo demonstra como configurar os tempos de espera pelas respostas de Web Services.
No fim do tempo,
caso a resposta não tenha sido recebida,
é lançada uma exceção.
</p>
<p>
O JAX-WS distingue dois <i>timeouts</i> distintos:
<ul>
<li>
<i>connection</i> - quando tempo deve esperar até se estabelecer uma ligação com o servidor;
</li>
<li>
<i>receive</i> - quando tempo deve esperar até receber a resposta a um pedido feito ao servidor.
</li>
</ul>
</p>

<p>
Exemplo:
</p>
<ul>
    <li>
        <a href="hello-ws-cli_timeout.zip">Cliente de Web Service com timeouts
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
    </li>
    <li>
		Para verificar o comportamento do timeout do cliente,
		pode experimentar
		<a href="hello-ws_sleep.zip">este servidor</a>
		que introduz um atraso artificial na execução das suas operações.
    </li>
</ul>

<p>&nbsp;</p>

<hr />

<h2 id="oneway">Operações unidirecionais</h2>
<img src="oneway.png" height="45" />
<p>

As operações unidirecionais de Web Service são aquelas que não enviam resposta, logo o programa cliente é desbloqueado mal a mensagem de pedido saia através da rede. 
Este exemplo demonstra como definir operações unidirecionais.
</p>

<ul>
    <li>
        <a href="bye-ws_oneway_sleep.zip">Web Service Implementation-first com operação one-way
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        Lançar o servidor,
        abrir o WSDL gerado e confirmar o que é diferente na operação one-way.
        No caso <i>contract-first</i>,
        deverão escrever um WSDL semelhante ao que é gerado neste exemplo.
        A operação <i>one-way</i> não declara <tt>output</tt>
        no <tt>portType</tt> e no <tt>binding</tt>.
    </li>

    <li>
        <a href="bye-ws-cli_oneway.zip">Cliente de Web Service com operação one-way
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        - o cliente é idêntico ao habitual,
        mas podem confirmar que não espera pela conclusão da execução da operação <i>one-way</i> no servidor
    </li>

</ul>

<p>&nbsp;</p>

<hr />

<h2 id="async">Operações assíncronas</h2>

<img src="async.gif" height="120" />
<!-- image credits: http://java.boot.by/scdjws5-guide/ch12s03.html -->

<p>
Até agora vimos exemplos de invocações remotas síncronas: o cliente faz um pedido ao servidor e fica bloqueado à espera da resposta.
Caso o cliente não pretenda ficar bloqueado à espera da resposta do servidor, é possível fazê-lo através de uma <b>invocação assíncrona</b>.
Neste caso o cliente faz o pedido, continua a executar, e vai receber a resposta mais tarde.
</p>

<p>
A forma de fazer invocações assíncronas é através dos métodos com sufixo <tt>Async</tt>.
Para que estes métodos sejam gerados é necessário do lado do cliente indicar um ficheiro de <i>binding</i>, na pasta <tt>src/jaxws</tt>.
Os <i>stubs</i> assim gerados passam a incluir tanto os métodos para invocação síncrona como assíncrona.
</p>

<pre class="prettyprint lang-xml">
&lt;bindings
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/jaxws&quot; &gt;
     &lt;bindings node=&quot;wsdl:definitions&quot;&gt;
         &lt;enableAsyncMapping&gt;true&lt;/enableAsyncMapping&gt;
     &lt;/bindings&gt;
&lt;/bindings&gt;
</pre>

<p>Existem duas formas alternativas de programar um cliente que recorre a chamadas assíncronas. 
De seguida explicamos cada uma.</p>

<h3>Invocação com <i>polling</i></h3>
<p>
Para uma invocação assíncrona,
o cliente deve executar um método com o sufixo <tt>Async</tt> e
de seguida usar o método <tt>Response.isDone()</tt> para verificar se a resposta já chegou.
Nesta solução o cliente invoca o método remoto sem ficar bloqueado,
ficando responsável por verificar, periodicamente, se o servidor já respondeu (através do objecto <tt>Response</tt>).
Só depois da resposta ter chegado,
pode então o cliente obter o seu resultado através do objecto <tt>Response</tt>.
</p>

<pre class="prettyprint lang-java">
    // asynchronous call with polling
    Response<EchoResponse> response = port.echoAsync(name);

    while (!response.isDone()) {
        Thread.sleep(10 /* milliseconds */);

        /* while waiting for response do something else... */
    	System.out.print(".");
    	System.out.flush();
    }

    System.out.print("Asynchronous call result: ");
    System.out.println(response.get().getReturn());
</pre>

<h3>Invocação com <i>callback</i></h3>
<p>
Um outro modelo de funcionamento é o registo de um objecto de <i>callback</i>
do tipo <tt>AsyncHandler</tt> aquando da execução da chamada assíncrona.
Quando a resposta chega, um método desse objeto é invocado. 
Este funcionamento é semelhante ao atendimento de interrupções num processador. 
A rotina de <i>callback</i> corresponde à rotina de atendimento da interrupção. 
O receber uma resposta do servidor corresponde à interrupção.
</p>

<pre class="prettyprint lang-java">
    static boolean finished = false;

    ...

    // asynchronous call with callback
    port.echoAsync(name, new AsyncHandler<EchoResponse>() {
        @Override
        public void handleResponse(Response<EchoResponse> response) {
            try {
                System.out.println();
                System.out.print("Asynchronous call result arrived: ");
                System.out.println(response.get().getReturn());
                finished = true;
            } catch (InterruptedException e) {
                System.out.println("Caught interrupted exception.");
                System.out.print("Cause: ");
                System.out.println(e.getCause());
            } catch (ExecutionException e) {
                System.out.println("Caught execution exception.");
                System.out.print("Cause: ");
                System.out.println(e.getCause());
            }
        }
    });
		
    while (!finished) {
	    // do something else while waiting..
    	Thread.sleep(10 /* milliseconds */);
    	System.out.print("."); 
    	System.out.flush();
    }
</pre>
<br/>
<p>
Em ambos os casos, a resposta é obtida invocando o método <tt>response.get()</tt>, que pode lançar uma exceção caso esta tenha sido retornada pelo método remoto.
Caso o método remoto retorne <tt>Void</tt>, este método lançará uma <tt>NullPointerException</tt>.
Caso contrário, o objecto retornado pode ser obtido com o método <tt>getReturn()</tt>.
</p>

<p>Consultar o exemplo de cliente-servidor com invocações assíncronas:</p>
<ul>
    <li>
        <a href="echo-ws_async.zip">Web Service com invocações assíncronas
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        - Lançar o servidor da forma habitual
    </li>

    <li>
        <a href="echo-ws-cli_async.zip">Cliente de Web Service com invocações assíncronas
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        - O cliente é diferente do habitual,
        porque não fica bloqueado à espera da resposta do servidor.
    </li>

</ul>
<p>
Repare que não é preciso alterar o servidor para que o cliente possa fazer invocações assíncronas.
Apenas é necessário um <i>stub</i> diferente.
</p>


<p>
&nbsp;
</p>

</div>

<hr />

<h1 id="exercicio">Exercício</h1>
<p>
    O objetivo deste exercício é adaptar o código do módulo <tt>pts</tt> do projeto de forma a que as chamadas passem a ser feitas assincronamente. 
	Como será discutido nas aulas teóricas, esta extensão permitirá implementar o protocolo de replicação da segunda parte do projeto de forma mais eficiente.
	Hoje estamos a aprender a técnica das chamadas assíncronas.
</p>
<ol>
    <li>
    Clonar o código da primeira entrega do projeto.<br />
    Esta cópia vai ser usada apenas para este exercício.
    </li>
    <li>
    Criar pasta tt>jaxws</tt> (caso ainda não exista) na diretoria: <tt>pts-ws-cli/src</tt> <br />
    </li>
    <li>
    Adicionar um ficheiro <tt>binding.xml</tt> à pasta <tt>jaxws</tt>, semelhante ao <a href="#async">apresentado acima</a>, que ativa a opção <tt>enableAsyncMapping</tt>. <br />
    </li>
	<li>
	Execute o comando de geração de código:<ul>
	<li><tt>mvn clean generate-sources</tt></li>
	</ul>
	O código gerado no <i>stub</i> vai conter métodos com o sufixo <tt>Async</tt>, que permitem fazer as chamadas assíncronas.
	</li>

    <li>Modificar a definição da classe <tt>PointsClient</tt> para remover a declaração de implementação da interface <tt>PortType</tt> e 
as anotações <tt>@Override</tt>.
        <pre class="prettyprint lang-java">
    public class PointsClient {
        </pre>
    Este passo evita ter que implementar os métodos assíncronos para todas as operações.<br />
	Neste exercício apenas vamos usar a operação <tt>pointsBalance</tt> que devolve o saldo de pontos.
    </li>
</ol>
<h3>Invocação com <i>polling</i></h3>
<ol>
    <li>Adicionar o seguinte método à classe <tt>PointsClient</tt>:</li>
    <pre class="prettyprint lang-java">
    public Response&lt;PointsBalanceResponse&gt; pointsBalanceAsync(String userEmail) {
        return port.pointsBalanceAsync(userEmail);
    }
    </pre>
    <li>Adicionar no método <tt>main()</tt> da classe <tt>PointsClientApp</tt></li>
    <pre class="prettyprint lang-java">
    import javax.xml.ws.Response;
    import java.util.concurrent.ExecutionException;

    // ... (acrescentar no fim do método)

    String userEmail = "user@example.com";
    client.activateUser(userEmail);
    // asynchronous call with polling
    Response<PointsBalanceResponse> response = client.pointsBalanceAsync(userEmail);

    while (!response.isDone()) {
        Thread.sleep(10 /* milliseconds */);
        System.out.print(".");
		System.out.flush();
    }

    try {
        System.out.println("(Polling) asynchronous call result: " + response.get().getReturn());
    } catch (ExecutionException e) {
        System.out.println("Caught execution exception.");
        System.out.print("Cause: ");
        System.out.println(e.getCause());
    }
    </pre>
    <li>Na pasta <tt>pts-ws-cli</tt> fazer:<ul>
        <li><tt>mvn install -DskipITs</tt></li>
		<li><small>(a opção <tt>skipITs</tt> diz ao Maven para não executar os testes de integração)</small></li>
    </ul></li>
    <li>Lançar o servidor <tt>pts-ws</tt>:<ul>
        <li><tt>mvn compile exec:java</tt></li>
    </ul></li>
    <li>Lançar o cliente <tt>pts-ws-cli</tt>:<ul>
        <li><tt>mvn exec:java -Dexec.cleanupDaemonThreads=false</tt></li> 
		<li><small>(a opção <tt>cleanupDaemonThreads</tt> diz ao Maven para não interferir com as <i>threads</i> auxiliares usadas nas chamadas assíncronas)</small></li>
    </ul></li>
    <li>Analisar o resultado</li>
    <li>Experimentar introduzir um atraso no <tt>pts-ws</tt>, recompilar, executar novamente e comparar o resultado</li>
    <li>Compare a invocação síncrona com a invocação assíncrona com <i>polling</i>. 
	Em ambos se espera pela resposta. Qual é a diferença entre ambos?</li>
</ol>
<h3>Invocação com <i>callback</i></h3>
<ol>
    <li>Adicionar o seguinte método à classe <tt>PointsClient</tt>:</li>
    <pre class="prettyprint lang-java">
    public Future&lt;?&gt; pointsBalanceAsync(String userEmail, AsyncHandler&lt;PointsBalanceResponse&gt; asyncHandler) {
        return port.pointsBalanceAsync(userEmail, asyncHandler);
    }
    </pre>
    <li>Adicionar na classe <tt>PointsClientApp</tt>:</li>
    <pre class="prettyprint lang-java">
    import javax.xml.ws.Response;

    public class PointsClientApp {
        static boolean received = false;
        
        public static void main(String[] args) throws Exception {
    
            // ... (acrescentar no fim do método)

            String userEmail1 = "user@example.com";
            client.activateUser(userEmail1);
            client.addPoints(userEmail1, 1100);

            // asynchronous call with callback
            client.pointsBalanceAsync(userEmail1, new AsyncHandler&lt;PointsBalanceResponse&gt;() {
                @Override
                public void handleResponse(Response&lt;PointsBalanceResponse&gt; response) {
                    try {
                        System.out.println();
                        System.out.print("(Callback) Asynchronous call result arrived: ");
                        System.out.println(response.get().getReturn());
                        received = true;
                    } catch (InterruptedException e) {
                        System.out.println("Caught interrupted exception.");
                        System.out.print("Cause: ");
                        System.out.println(e.getCause());
                    } catch (ExecutionException e) {
                        System.out.println("Caught execution exception.");
                        System.out.print("Cause: ");
                        System.out.println(e.getCause());
                    }
                }
            });

            while (!received) {
                Thread.sleep(10 /* milliseconds */);
                System.out.print(".");
                System.out.flush();
            }
    </pre>
    <li>Na pasta <tt>pts-ws-cli</tt> fazer:<ul>
        <li><tt>mvn install -DskipITs</tt></li>
    </ul></li>
    <li>Lançar o servidor <tt>pts-ws</tt>:<ul>
        <li><tt>mvn compile exec:java</tt></li>
    </ul></li>
    <li>Lançar o cliente <tt>pts-ws-cli</tt>:<ul>
        <li><tt>mvn exec:java -Dexec.cleanupDaemonThreads=false</tt></li> 
    </ul></li>
    <li>Porque é que a variável <i>received</i> necessita de ser <i>static</i>?</li>
    <li>Quais as diferenças entre usar <i>callback</i> em vez de <i>polling</i>?</li>
</ol>


<div class="rodape">
<p>
&copy; Docentes de Sistemas Distribuídos,
<a href="http://www.dei.tecnico.ulisboa.pt/">Dep. Eng. Informática</a>,
<a href="http://www.ist.eu">Técnico Lisboa</a><br />
</p>
</div>

</body></html>
