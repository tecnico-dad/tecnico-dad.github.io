<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <link rel="stylesheet" type="text/css" href="../_css/labs-sd.css">

    <link href="../_prettify/prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="../_prettify/prettify.js"></script>

    <title>Criptografia</title>
</head>

<body onload="prettyPrint()">

<body>

<div class="contexto">
    <p>
        <a href="../index.html">Labs SD</a> &gt;
    </p>
</div>

<div class="titulo" id="1">
    <h1>Criptografia</h1>
</div>

<div class="objectivos">
    <h2>Objectivos</h2>
    <ul>
        <li>Utilizar os mecanismos criptográficos da plataforma Java</li>
        <li>Concretizar um mecanismo de segurança para um gRPC</li>
    </ul>
</div>
<!--/br-->
<!--div class="laboratorio">
    <h2>No laboratório:</h2>
    <ul>
        <li>Testar a criptografia Java, em especial, a cifra simétrica</li>
    </ul>
</div-->

<div class="indice">
</div>

<div class="corpo">
    <!--h2 id="conteudos">Conteúdos</h2-->
    <p class="textos"><h3>Resumos:</h3>
        <ul>
            <li><a href="seguranca-java/index.html">Segurança na plataforma Java</a></li>
            <li><a href="criptografia/index.html">Mecanismos criptográficos</a></li>
            <li><a href="binarios-texto/index.html">Representação de dados binários em texto</a></li>
        </ul>
    </p>
    <p class="exemplos" id="crypto"><h3>Exemplos:</h3>
        <ul>
            <li><a href="https://github.com/tecnico-distsys/example_crypto" target="_blank">Criptografia em Java <img src="../_img/github.png" alt="GitHub" height="16"></a></li>
            <ul>
                <li>Para experimentar o código: fazer <b><i>Clone or Download</b></i> e depois seguir as instruções do <b><tt>README</tt></b></li>
            </ul>
            </li>
            <ul>
                <li>Cifra simétrica</li>
                <li>Cifra assimétrica</li>
                <li>Resumo (<i>digest</i>)</li>
                <li>Geração de números aleatórios seguros</li>
                <li>Assinaturas digitais</li>
                <li>Leitura e escrita de chaves criptográficas</li>
                <!--li>Criptografia em texto (XML)</li-->
            </ul>
        </ul>
		<ul>
			<li>Para executar uma demonstração da criptografia, escrever:</li>
			<ul>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
			<li>Para correr os testes:</li>
			<ul>
				<li><tt>mvn test</tt></li>
			</ul>
		</ul>
    </p>

<p>
&nbsp;
</p>

<h2 id="exercicio">Mini-Exercício</h2>

<p>
Neste exercício vamos acrescentar segurança a uma aplicação distribuída que usa gRPC.
Nomeadamente, vamos garantir <b>integridade</b> da comunicação entre servidor e cliente.
</p>


<ol type="I">
	<li>
<b>Fornecedor gRPC / <i>Supplier</i></b><br />
<br />
O ponto de partida para o exercício é um <a href="https://github.com/tecnico-distsys/exercise_grpc-supplier" target="_blank"></a>cliente-servidor que usa gRPC <img src="../_img/github.png" alt="GitHub" height="16"></a>.<br />
O servidor é um fornecedor de produtos para venda.
O cliente contacta o servidor, chamando a operação remota <tt>listProducts</tt>, e o servidor responde com uma lista de produtos.
	</li>
	<ol type="1">
		<li>
Faça <b><i>Clone or Download</b></i> do ponto de partida.
		</li>
		<li>
Leia os <tt>README</tt> e analise o código, começando pelo <tt>contract</tt>, depois pelo <tt>server</tt> e finalmente o <tt>client</tt>.
		</li>
		<li>
Para construir e executar:
		</li>
		<ul>
			<li>Contrato</li>
			<ul>
				<li>Compilar o <i>Protobuf</i> e gerar código Java</li>
				<li>Instalar o módulo Maven no repositório local, para poder ser usado como dependência</li>
				<li><tt>mvn install</tt></li>
			</ul>
			<li>Servidor</li>
			<ul>
				<li>Compilar e executar o servidor</li>
				<li>Fica à espera de pedidos de clientes</li>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
			<li>Cliente</li>
			<ul>
				<li>Abrir outro terminal</li>
				<li>Compilar e executar o cliente</li>
				<li>Prepara o pedido, imprime-o na consola, faz a chamada remota, e imprime o resultado na consola</li>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
		</ul>
		<li>
<b>Perguntas</b>
		</li>
		<ol type="a">
			<li>
Onde estão definidas as operações remotas e respetivas mensagens?
			</li>
			<li>
Para que servem os objetos <i>Builder</i> usados no cliente e no servidor?
			</li>
			<li>
Em que porto fica o servidor à escuta de pedidos? Onde está definido?
			</li>
		</ol><!-- type="a" -->
	</ol><!-- type="1" -->

	<p>&nbsp;</p>

	<!-- II -->
	<li>
<b>Distribuição de chaves</b><br />
<br />
A lista devolvida pelo servidor ao cliente pode ser intercetada e modificada por um atacante.<br />
É necessário acrescentar uma <b>assinatura</b> para proteger a resposta do servidor.<br />
<br />
Vamos fazer uma assinatura baseada numa cifra simétrica, um MAC (<i>Message Authentication Code</i>).<br />
O servidor e o cliente vão partilhar uma chave para permitir assinar e verificar a mensagem.<br />
A chave foi gerada e guardada num ficheiro.
	</li>
	<ol type="1">
		<li>
Descarregue e descomprima as <a href="./keys.zip">chaves de exemplo <img src="../_img/zip.png" alt="ZIP" /></a>.
		</li>
		<li>
Copie a chave secreta para o servidor (pasta <tt>/src/main/resources</tt>).
		</li>
		<li>
Copie a mesma chave para o cliente (pasta <tt>/src/main/resources</tt>).
		</li>
		<li>
Quando precisar da chave, no servidor ou no cliente, pode usar um código semelhante ao seguinte para ler o seu valor a partir do recurso da aplicação:
		</li>
<pre class="prettyprint lang-java">
...

import java.security.Key;

import static javax.xml.bind.DatatypeConverter.printHexBinary;

import java.io.InputStream;

...

	public static Key readKey(String resourcePath) throws Exception {
		System.out.println("Reading key from resource " + resourcePath + " ...");
		
		InputStream fis = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourcePath);
		byte[] encoded = new byte[fis.available()];
		fis.read(encoded);
		fis.close();
		
		System.out.println("Key:");
		System.out.println(printHexBinary(encoded));
		SecretKeySpec keySpec = new SecretKeySpec(encoded, "AES");

		return keySpec;
	}

...
</pre>
		<li>
<b>Perguntas</b>
		</li>
		<ol type="a">
			<li>
Qual é o tamanho da chave?
			</li>
			<li>
Porque é necessário copiar a mesma chave para o cliente e para o servidor?
			</li>
		</ol><!-- type="a" -->

	</li>

	</ol><!-- type="1" -->

	<p>&nbsp;</p>

	<!-- III -->
	<li>
<b>Acrescentar assinatura à definição da operação</b><br />
<br />
Vamos agora acrescentar uma assinatura à definição da operação RPC.
	</li>
	<ol type="1">
		<li>
Aceder à definição <i>Protobuf</i> no <tt>contract</tt>.
		</li>
		<li>
Acrescentar a definição de uma nova estrutura de dados para a assinatura, 
composta por identificador do assinante e o valor a calcular.
		</li>
<pre class="prettyprint lang-java">
...

message Signature {
  string signerId = 1;
  bytes value = 2;
}

...
</pre>
		<li>
Acrescentar a definição de uma mensagem para a resposta original com uma assinatura:
		</li>
<pre class="prettyprint lang-java">
...

message SignedResponse {
  ProductsResponse response = 1;
  Signature signature = 2;
}

...
</pre>
		<li>
Modificar o tipo do resultado da operação RPC:
		</li>
<pre class="prettyprint lang-java">
...

  rpc listProducts(ProductsRequest) returns (<b>SignedResponse</b>);

...
</pre>
		<li>
Para reconstruir:
		</li>
		<ul>
			<li>Compilar o <i>Protobuf</i> e gerar código Java</li>
			<li>Reinstalar o módulo Maven no repositório local</li>
			<li><tt>mvn install</tt></li>
		</ul>
		<li>
Consulte o código Java gerado para verificar o que mudou.
		</li>
		<p>&nbsp;</p>
		<li>
Atualizar o código do servidor para refletir a modificação:
		</li>
<pre class="prettyprint lang-java">
...

import ...
import example.grpc.SignedResponse;
import example.grpc.Signature;

...
    @Override
    public void listProducts(ProductsRequest request, StreamObserver&lt;<b>SignedResponse</b>&gt; responseObserver) {
...
</pre>
        <li>
Atualizar também a chamada do lado do cliente:
		</li>
<pre class="prettyprint lang-java">
...

import ...
import example.grpc.SignedResponse;
import example.grpc.Signature;

...
        <b>SignedResponse</b> response = stub.listProducts(request);
...
</pre>
	</ol><!-- type="1" -->		



	<p>&nbsp;</p>

	<!-- IV -->
	<li>
<b>Assinar a resposta a enviar</b><br />
<br />
Uma das implementações possíveis de um MAC é um resumo cifrado com a chave simétrica.<br />
Vamos então calcular o resumo da resposta e depois cifrar esse resumo com a chave secreta.
	</li>
	<ol type="1">
		<li>
Aceder à classe de implementação do serviço no <tt>server</tt>.
		</li>
		<li>
Para calcular o resumo, criar um objecto <tt><b>MessageDigest</b></tt> com o algoritmo <tt>SHA-256</tt><br />
(consultar a <a href="https://docs.oracle.com/javase/8/docs/api/java/security/MessageDigest.html">documentação</a> e o <a href="https://github.com/tecnico-distsys/example_crypto/blob/master/src/test/java/pt/tecnico/crypto/MACTest.java">exemplo</a> sobre este objeto).
		</li>
		<li>
Para obter os dados a resumir, serializar o resultado com o seguinte método:
		</li>
<pre class="prettyprint lang-java">
...
        byte[] responseBytes = response.toByteArray();
...
</pre>
		<li>
Para cifrar o resumo, criar um objecto <tt><b>Cipher</b></tt> com o algoritmo <tt>AES/ECB/PKCS5Padding</tt> e 
inicializar em <tt>ENCRYPT_MODE</tt> com a chave<br />
(consultar a <a href="https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html">documentação</a> e o <a href="https://github.com/tecnico-distsys/example_crypto/blob/master/src/test/java/pt/tecnico/crypto/SymCryptoTest.java">exemplo</a> sobre este objeto).
		</li>
		<li>
Preencher a assinatura e devolver a resposta que engloba a resposta anterior e a assinatura.
		</li>
		<li>
Para testar:
		</li>
		<ul>
			<li>Servidor</li>
			<ul>
				<li>Compilar e executar o servidor</li>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
			<!--li>Cliente</li>
			<ul>
				<li><tt>mvn compile exec:java</tt></li>
			</ul-->
		</ul>
		<li>
<b>Perguntas</b>
		</li>
		<ol type="a">
			<li>
O que significa cada campo na expressão <tt>AES/ECB/PKCS5Padding</tt>?
			</li>
			<!--li>
Concorda com a escolha?<br /> 
Consulte a <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Cipher">documentação do JCE</a> para fundamentar a sua resposta. 
Caso discorde, escolha uma alternativa mais segura.
			</li-->
		</ol><!-- type="a" -->
	</ol><!-- type="1" -->		

	<p>&nbsp;</p>

	<!-- V -->
	<li>
<b>Verificar a assinatura da resposta recebida</b><br />
<br />
Para verificar a assinatura é necessário calcular o resumo da mensagem recebida e comparar com a decifra do resumo recebido na assinatura.
	</li>
	<ol type="1">
		<li>
Aceder à classe do <tt>client</tt>.
		</li>
		<li>
Para decifrar o resumo cifrado recebido na assinatura, criar um objecto <tt>Cipher</tt> com o algoritmo <tt>AES/ECB/PKCS5Padding</tt>,
e inicializar em <tt>DECRYPT_MODE</tt> com a chave.
		</li>
		<li>
Para recalcular o resumo, criar um objecto <tt>MessageDigest</tt> com o algoritmo <tt>SHA-256</tt>.
Calcular o resumo a partir dos dados recebidos.
		</li>
		<li>
Comparar o resumo decifrado com o resumo calculado:
		</li>
<pre class="prettyprint lang-java">
...
        if (Arrays.equals(digest, decipheredDigest))
            System.out.println("Signature is valid! Message accepted! :)");
        else
            System.out.println("Signature is invalid! Message rejected! :(");
...
</pre>
		<li>
Para testar:
		</li>
		<ul>
			<li>Servidor</li>
			<ul>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
			<li>Cliente</li>
			<ul>
				<li><tt>mvn compile exec:java</tt></li>
				<li>Consultar a consola para ver o que foi acrescentado à resposta.</li>
			</ul>
		</ul>
	</ol><!-- type="1" -->		

	<p>&nbsp;</p>

	<!-- VI -->
	<li>
<b>Verificar eficácia da assinatura</b><br />
<br />
Vamos modificar o conteúdo da mensagem de resposta depois de assinada, 
para confirmar que o cliente é capaz de detetar a alteração.
	</li>
	<ol type="1">
		<li>
No servidor, após a realização da assinatura, modificar um dos campos de um dos produtos.
		</li>
		<ul>
			<li>
Para criar um objeto modificado a partir de um objeto existente pode-se usar o método <tt>toBuilder()</tt>.
<!--
os objetos construídos para os pedidos e respostas são imutáveis, ou seja, não podem ser mudados depois de construídos.
-->
			</li>
		</ul>
		<li>
Para testar:
		</li>
		<ul>
			<li>Servidor</li>
			<ul>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
			<li>Cliente</li>
			<ul>
				<li><tt>mvn compile exec:java</tt></li>
			</ul>
		</ul>
		<li>
<b>Perguntas</b>
		</li>
		<ol type="a">
			<li>
O cliente conseguiu detetar a alteração?
			</li>
			<li>
O cliente consegue detetar mensagens repetidas?<!--br />
Ou seja, o cliente é resistente a um ataque de repetição?-->
			</li>
		</ol>
	</ol>
	
	<p>&nbsp;</p>

	<!-- VII -->
	<li>
<b>Alínea secreta</b>
	</li>
    <p>
O resto do enunciado será entregue na aula. <br />
O objectivo será estender a solução resultante do enunciado acima.<br />
<br />
    </p>

</ol><!-- type="I" -->


  <div class="objectivos">
    <h2>Entrega da solução</h2>

    <p>Fénix, Avaliação, Projetos, <b>mini Exercício 3</b></p>

    <p>
      A solução completa deverá ser submetida no Fénix
      <b>antes do fim da sua aula de laboratório</b>.<br />
      Trabalhos submetidos depois da hora de fim da aula não serão
      considerados.<br />
    </p>

    <p>
      <b>Ter atenção ao seguinte:</b>
    </p>
    <ul>
      <li>
        Só serão aceites trabalhos de estudantes que estiveram presentes no
        laboratório.
      </li>
      <li>
        Assegure-se que a solução é enviada em formato ZIP e que não contém
        código compilado (faça <tt>mvn clean</tt> antes de criar o zip)
      </li>
    </ul>
  </div>

<p>&nbsp;</p>

<span style="color:grey">
<ol type="I" start="10">
	<li>
<b>Alínea extra: criptografia assimétrica</b><br />
<br />
O exercício usou cifra simétrica para calcular um MAC (<i>Message Authentication Code</i>).<br />
Modifique a solução para usar cifra assimétrica RSA na assinatura digital:<br />
o servidor deve assinar com a sua chave privada;<br />
o cliente deve verificar com a chave pública do servidor.
</ol>
</span>

</div>

<p>&nbsp;</p>

<hr />

<div class="rodape">
<p>
&copy; Docentes de Sistemas Distribuídos,
<a href="http://www.dei.tecnico.ulisboa.pt/">Dep. Eng. Informática</a>,
<a href="http://www.ist.eu">Técnico Lisboa</a><br />
</p>
</div>

</body></html>
