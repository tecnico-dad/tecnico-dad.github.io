<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
    <link rel="stylesheet" type="text/css" href="../_css/labs-sd.css">

    <link href="../_prettify/prettify.css" type="text/css" rel="stylesheet" />
    <script type="text/javascript" src="../_prettify/prettify.js"></script>

    <title>Web Services IV</title>
</head>

<body onload="prettyPrint()">

<div class="contexto">
    <p>
        <a href="../index.html">Labs SD</a> &gt;
    </p>
</div>

<div class="titulo" id="1">
    <h1>Web Services IV</h1>
</div>

<div class="objectivos">

    <h2>Objectivos</h2>
    <ul>
        <li>Configurar o limite de tempo de espera do cliente</li>
        <li>Invocar uma opera袯 unidireccional <i>(one-way)</i></li>
        <li>Fazer chamadas ass쭣ronas <i>(async)</i></li>
    </ul>
</div>

<div class="indice">
<p><b>̮dice:</b></p>
<ul>
    <li><a href="#timeout">Limite de tempo</a></li>
    <li><a href="#oneway">Opera败s unidireccionais</a></li>
    <li><a href="#async">Opera败s ass쭣ronas</a></li>
</ul>
</div>

<div class="corpo">

<hr />

<h2 id="timeout">Limite de tempo</h2>
<img src="clock.png" height="60" />
<p>
O exemplo abaixo demonstra como configurar os tempos de espera pelas respostas de Web Services.
No fim do tempo,
caso a resposta n⭠tenha sido recebida,
矡tirada uma excep袯.
</p>
<p>
O JAX-WS distingue dois <i>timeouts</i> distintos:
<ul>
<li>
<i>connection</i> - quando tempo deve esperar at石e estabelecer uma liga袯 com o servidor;
</li>
<li>
<i>receive</i> - quando tempo deve esperar at矲eceber a resposta a um pedido feito ao servidor.
</li>
</ul>
</p>

<p>
Exemplo:
</p>
<ul>
    <li>
        <a href="hello-ws-cli_timeout.zip"><b>Web Service client with timeouts</b>
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
    </li>
    <li>
		Para verificar o comportamento do timeout do cliente,
		pode experimentar
		<a href="hello-ws_sleep.zip">este servidor</a>
		que introduz um atraso artificial na execu袯 das suas opera败s.
    </li>
</ul>

<p>&nbsp;</p>

<hr />

<h2 id="oneway">Opera败s unidireccionais</h2>
<img src="oneway.png" height="45" />
<p>
Este exemplo demonstra como definir opera败s unidireccionais, ou seja,
opera败s de Web Service que n⭠enviam resposta.
</p>

<ul>
    <li>
        <a href="bye-ws_oneway_sleep.zip">Implementation-first Web Service with one-way operation that sleeps
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        Lan栲 servidor,
        abrir o WSDL gerado e confirmar o que 矤iferente na opera袯 one-way.
        No caso <i>contract-first</i>,
        dever⭠escrever um WSDL semelhante ao que 矧erado neste exemplo,
        ou seja, 
        a opera袯 <i>one-way</i> n⭠declara <tt>output</tt>
        no <tt>portType</tt> e no <tt>binding</tt>.
    </li>

    <li>
        <a href="bye-ws-cli_oneway.zip">Web Service client of one-way operation
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        - o cliente 矩d魴ico ao habitual,
        mas podem confirmar que n⭠espera pela conclus⭠da execu袯 da opera袯 <i>one-way</i> no servidor
    </li>

</ul>

<p>&nbsp;</p>

<hr />

<h2 id="async">Opera败s ass쭣ronas</h2>

<img src="async.gif" height="120" />
<!-- image credits: http://java.boot.by/scdjws5-guide/ch12s03.html -->

<p>
Em situa败s em que o cliente n⭠pretenda ficar bloqueado �spera da resposta do servidor, 
矰oss쵥l faz謬o atrav豠de uma invoca袯 ass쭣rona.
</p>

<ul>
    <li>
        <a href="echo-ws_async.zip">Web Service for asynchronous invocations
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        - Lan栲 servidor da forma habitual
    </li>

    <li>
        <a href="echo-ws-cli_async.zip">Web Service client of asynchronous operations
        <img src="../_img/zip.png" alt="ZIP" ></a><br />
        - O cliente 矤iferente do habitual,
        porque n⭠fica bloqueado �spera da resposta do servidor.
    </li>

</ul>

<p>
Uma poss쵥l maneira de fazer invoca败s ass쭣ronas 矡trav豠dos m賯dos com sufixo <tt>Async</tt>. 
Para que estes m賯dos sejam gerados 矮ecess౩o do lado do cliente indicar um ficheiro de <i>binding</i>. 
Os <i>stubs</i> assim gerados passam a incluir tanto os m賯dos para invoca袯 sincrona como ass쭣rona.
</p>

<pre class="prettyprint lang-xml">
&lt;bindings
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot;    
    xmlns=&quot;http://java.sun.com/xml/ns/jaxws&quot; &gt;   
     &lt;bindings node=&quot;wsdl:definitions&quot;&gt;
         &lt;enableAsyncMapping&gt;true&lt;/enableAsyncMapping&gt;
     &lt;/bindings&gt;
&lt;/bindings&gt;
</pre>

<p>
Para uma invoca袯 ass쭣rona, 
o cliente deve executar um m賯do com o sufixo <tt>Async</tt> e 
de seguida usar o m賯do <tt>Response.isDone()</tt> para verificar se a resposta j�hegou. 
Nesta solu袯 o cliente invoca o m賯do remoto sem ficar bloqueado, 
ficando respons൥l por verificar quando o servidor j�espondeu atrav豠do objecto <tt>Response</tt>. 
S񟣥pois da resposta ter chegado, 
pode ent⭠obter o seu resultado atrav豠do objecto <tt>Response</tt>. 
</p>

<pre class="prettyprint lang-java">
    // asynchronous call with polling
    Response<EchoResponse> response = port.echoAsync(name);

    while (!response.isDone()) {
        Thread.sleep(100 /* milliseconds */);

        /* while waiting for response do other calls... */
        String result = port.fastEcho(name);
        System.out.print("Synchronous call result: ");
        System.out.println(result);
    }

    System.out.println("Async->" + response.get().getReturn());
</pre>

<p>
Um outro modelo de funcionamento 矯 registo de um objecto de <i>callback</i> 
do tipo <tt>AsyncHandler</tt> aquando da execu袯 da chamada ass쭣rona.
Quando a resposta chega, 
um m賯do desse objecto 矩nvocado.
</p>

<pre class="prettyprint lang-java">
    static boolean finished = false;

...

    // asynchronous call with callback
    port.echoAsync(name, new AsyncHandler<EchoResponse>() {
        @Override
        public void handleResponse(Response<EchoResponse> response) {
            try {
                System.out.println();
                System.out.print("Asynchronous call result arrived: ");
                System.out.println(response.get().getReturn());
                finished = true;
            } catch (InterruptedException e) {
                System.out.println("Caught interrupted exception.");
                System.out.print("Cause: ");
                System.out.println(e.getCause());
            } catch (ExecutionException e) {
                System.out.println("Caught execution exception.");
                System.out.print("Cause: ");
                System.out.println(e.getCause());
            }
        }
    });
		
    while (!finished) {
    	Thread.sleep(100);
    	System.out.print(".");
    	System.out.flush();
    }
</pre>

<p>
Em ambos os casos, 
a resposta 矯btida invocando o m賯do <tt>response.get()</tt> que lan柠uma excep袯 caso esta tenha sido retornada pelo m賯do remoto. 
Caso o m賯do remoto retorne <tt>Void</tt>, 
este m賯do lancar�ma <tt>NullPointerException</tt>. 
Caso contr౩o, 
o objecto retornado pode ser obtido com o m賯do <tt>getReturn()</tt>.
</p>
<p>
Repare que n⭠矰reciso alterar o servidor para que o cliente possa fazer invoca败s ass쭣ronas.
</p>

<p>
&nbsp;
</p>
<hr />
<h2>Exerc좩o</h2>
<h3>Quarta parte do projeto</h3>

<p>
O objetivo deste exerc좩o 矲eplicar o mediador e implementar o mecanismo de provas de vida entre mediador prim౩o e secund౩o.
</p>

<p>
1) Replicar o <tt>mediator-ws</tt>:
</p>
<ol type="a">
    <li>
    A forma mais simples de permitir m�las inst᭣ias do mediador 爠   parametrizar as propriedades de configura袯 com um n� de inst᭣ia, tal como se fez para o <tt>supplier-ws</tt>.
    </li>
    <li>
    Adicionar as seguintes defini败s ao <tt>pom.xml</tt> 
    (substituir CXX pelo identificador do grupo):<br />
<pre class="prettyprint lang-xml">
    ...
    &lt;group.id&gt;CXX&lt;/group.id&gt;

    &lt;ws.i&gt;1&lt;/ws.i&gt;

    &lt;ws.host&gt;localhost&lt;/ws.host&gt;
    &lt;ws.port&gt;807${ws.i}&lt;/ws.port&gt;
    &lt;ws.url&gt;http://${ws.host}:${ws.port}/mediator-ws/endpoint&lt;/ws.url&gt;
   
    &lt;ws.name&gt;${group.id}_Mediator&lt;/ws.name&gt;

    &lt;supplier.ws.name&gt;${group.id}_Supplier&lt;/supplier.ws.name&gt;    
    ...
</pre>
    </li>
    <ul>
        <li>
        O porto do URL do servi歠foi trocado para 8071, por omiss⭮
        </li>
        <li>
        O nome do servi歠n⭠inclui o n� de inst᭣ia
        porque o mediador secund౩o n⭠se regista no UDDI.
        O secund౩o "n⭠existe" para os clientes.
        </li>
    </ul>
    <li>
    Para lan栲 o Mediador Prim౩o:
    </li>
    <ul>
        <li>
        <tt>mvn compile</tt>
        </li>
        <li>
        <tt>mvn exec:java</tt><br />
        Por omiss⭬ ser� inst᭣ia 1, 
        que fica �scuta de pedidos no porto 8071 e 
        que se regista com o nome CXX_Mediator.
        </li>
    </ul>
    <li>
    Para lan栲 o Mediador Secund౩o:
    </li>
    <ul>
        <li>
        <tt>mvn exec:java <b>-Dws.i=2</b></tt><br />
        A inst᭣ia <b>2</b> fica �scuta de pedidos no porto 807<b>2</b> e n⭠se regista no UDDI.<br />
        </li>
    </ul>
</ol>
<p>
Cada inst᭣ia, ao arrancar, deve imprimir para a consola uma 
mensagem que indique se est� funcionar como prim౩o ou
como secund౩o
</p>
<p>
A partir deste momento j�xistem duas inst᭣ias do mediador a correr,
mas ambas v⭠ter estados diferentes, pelo que n⭠s⭠ainda r诬icas.
A replica袯 de estado ser�ratada depois.
</p>

<p>
2) Pretende-se agora modificar o contrato WSDL do mediador para permitir uma opera袯 unidireccional de prova de vida: <tt>imAlive</tt>.
</p>
<ol type="a">
    <li>
    Criar nova vers⭠do WSDL. 
    Pretende-se manter a compatibilidade com as opera败s existentes,
    pelo a modifica袯 seguinte deve apenas <b>acrescentar</b>
    elementos e opera败s.
    </li>
    <li>
    Sem alterar as opera败s j�efinidas no WSDL, 
    adicionar uma nova opera袯 <tt>imAlive</tt>.
    </li>
    <li>
    Fazer <tt>mvn generate-sources</tt>
    </li>
    <li>
    Implementar m賯do <tt>imAlive()</tt> no mediador onde:
    </li>
    <ul>
        <li>
        Se for mediador prim౩o, 
        retorna sem executar qualquer instru袯.
        </li>
        <li>
        Se for mediador secund౩o, 
        guarda a data da hora da chegada dessa prova de vida 
        (<i>timestamp</i> do instante em que o m賯do foi executado).
        </li>
    </ul>
    <li>
    Adicionar m賯do <tt>imAlive()</tt> no MediatorClient que executa a chamada do m賯do sobre o <i>stub</i>.
    </li>
</ol>

<p>
3) Pretende-se agora criar uma classe <tt>LifeProof.java</tt> que faz o lan栭ento de provas de vida do mediador prim౩o para secund౩o.
</p>
<ol type="a">
    <li>
    Para as provas de vida, ser�ecess౩o ter uma atividade que se executa de forma independente.<br /> 
    Esta atividade deve estender a classe <i>Thread</i> ou <i>TimerTask</i> do Java:
    </li>
    <ul>
        <li>
        <a href="thread.zip">thread
        <img src="../_img/zip.png" alt="ZIP"></a>
        - cria袯 de novas tarefas<br />
        </li>
        <li>
        <a href="timer.zip">timer
        <img src="../_img/zip.png" alt="ZIP"></a>
        - cria袯 de novas tarefas temporizadas<br />
        </li>
    </ul>
    <li>
    Uma vez escolhida <i>Thread</i> ou <i>TimerTask</i>,<br />
    criar uma classe <tt>LifeProof.java</tt> 
    no <tt>mediator-ws</tt>.
    </li>
    <li>
    Implementar o m賯do <tt>run</tt> da classe para que, se for o mediador prim౩o:
    </li>
    <ul>
        <li>
        Cria um cliente de mediador que aponta para o mediador secund౩o<br />
        (atrav豠de conven袯 estabelecida ou argumento expl좩to
        - n⭠usa UDDI porque se assume que 
        o prim౩o conhece o secund౩o)
        </li>
        <li>    
        De 5 em 5 segundos (valor configur൥l) chama o 
        m賯do <tt>imAlive()</tt> no servidor atrav豠do cliente
        </li>
    </ul>
    <li>
    Modificar a classe <tt>MediatorApp</tt> de modo a lan栲 a classe <tt>LifeProof</tt> antes de ficar �scuta de pedidos.
    </li>
</ol>

<p>
<b>
Pr򷨭os passos:
</b>
</p>

<p>
4) Acrescentar �lasse <tt>LifeProof.java</tt> o comportamento para o caso de ser o mediador secund౩o
</p>
<!--
, i.e.:
</p>
<ol> 
    - Detetar a falha do mediador principal por aus魣ia de provas de vida recebidas
    - Substituir no UDDI o mediador prim౩o pelo secund౩o
    - Passar o mediador secund౩o para "modo prim౩o"
</ol>
-->

<p>
5) Modificar novamente o contrato WSDL para conter as 
opera败s auxiliares de atualiza袯 de estado do mediador secund౩o.<br />
Estas opera败s devem ser unidireccionais.
</p>
<ul>
    <li><tt>
    void updateShopHistory(...<!-- ShoppingResultView srv, String cartId, int updateId-->)
    </tt></li>
    <li><tt>
    void updateCart(...<!--String cartId, ItemIdView itemId, int itemQty, int updateId-->)
    </tt></li>
</ul>

<p>
6) Implementar a l򦨣a de atualiza败s entre os dois mediadores, tendo em aten袯 a execu袯 de pedidos repetidos avaliando a idempot魣ia das opera败s
</p>

<p>
7) Utilizar as invoca败s de opera败s com <i>timeout</i> para alterar o <tt>MediatorClient</tt> de modo a 
garantir um <i>front-end</i> com a sem᭴ica pretendida no enunciado, tendo em aten袯 os v౩os tipos de exce败s de comunica袯.
</p>
<ul>
<!--li>
Apenas as opera败s principais
- i.e. aquelas que se destinam a ser chamadas dos clientes para o mediador -
necessitam de ser tolerantes a faltas.
</li-->
<li>
Ou seja, tornar o cliente tolerante a faltas de
quebra de liga袯 TCP dos pedidos-respostas HTTP
</li>
<li>
Os intervalos de tempo devem ser configur൥is
</li>
<li>
Mais informa袯 sobre <a href="../01-tools/exceptions/index.html">tratamento de exce败s</a> e 
sobre <a href="../05-ws1/junit-it/ws-exceptions.html">exce败s de Web Services</a>.
</li>
</ul>


<p>
<b>Continua袯 de bom trabalho!</b>
</p>


<p>
&nbsp;
</p>

</div>

<hr />


<div class="rodape">
<p>
&copy; Docentes de Sistemas Distribu죯s,
<a href="http://www.dei.tecnico.ulisboa.pt/">Dep. Eng. Inform೩ca</a>,
<a href="http://www.ist.eu">T袮ico Lisboa</a><br />
</p>
</div>

</body></html>
