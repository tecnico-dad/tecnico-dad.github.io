<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" type="text/css" href="../_css/labs-sd.css">

<link href="../_prettify/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../_prettify/prettify.js"></script>

<title>Invocação de procedimentos remotos com Java RMI</title>
</head>

<body onload="prettyPrint()">

<div class="contexto">
    <p>
        <a href="../index.html">Labs SD</a> &gt;
    </p>
</div>

<div class="titulo" id="1">
    <h1>Invocação de procedimentos remotos com Java RMI</h1>
</div>

<div class="objectivos">

<h2>Objetivos</h2>
<ul>
    <li>
    Distribuir uma aplicação originalmente centralizada usando o
    Java RMI (<i>Remote Method Invocation</i>)
    </li>
    <li>
    Aprofundar os conhecimentos sobre Java RMI
    </li>
    <li>
    Tomar contacto com os mecanismos de passagem de objetos do
    Java RMI
    </li>
</ul>

<h2>No laboratório:</h2>
<ul>
    <li>
    Esclarecer dúvidas
    </li>
    <li>
    Terminar o exercício
    </li>
</ul>
</div>

<div class="indice">
</div>

<div class="corpo">
<h2>Documentação</h2>
<ul>
    <li>
    Capítulo 5.5 Java RMI do livro principal da cadeira
    (Coulouris, <i>"Distributed Systems: Concepts and Design"</i>)
    </li>
</ul>

<h2 id="guiao">Exercício a resolver até ao fim da aula</h2>
<p>
Neste exercício iremos transformar uma implementação do Jogo do Galo (<i>Tic Tac Toe</i>) numa aplicação distribuída utilizando o Java RMI.
<br />
<img src="ttt.png" alt="Tic Tac Toe" height="90" /><br />
</p>
<p>
Partindo de uma versão Jogo do Galo feita para um cenário local,
pretende-se desenvolver uma variante do jogo onde a parte
computacionalmente mais pesada é realizada por um servidor remoto.
O servidor guarda as variáveis do jogo.
O cliente faz a interface com o utilizador.<br />
</p>








<ol type="I">
    <li>
	Jogo do Galo/<i>Tic Tac Toe</i>
	</li>
	<ol type="1">
		<li>
		Descarregue e descomprima o código fonte da <a href="./ttt-local.zip">implementação do jogo <img src="../_img/zip.png" alt="ZIP" /></a>.
		</li>	
		<li>
		Analise o código do jogo de forma a compreender a implementação.
		</li>
		<li>
		Compile e execute o código com o comando:<br />
		<tt>mvn compile exec:java</tt>
		<br />
		</li>
		<li>
		Experimente o jogo. Indique a posição escolhida para cada jogador, até terminar o jogo.<br />
		<br />
		</li>
	</ol>
		
		
	<li>
	Pretende-se que a nova versão do programa seja dividida em três processos: servidor, interface e cliente, através do Java RMI.<br />
    Descarregue e descomprima o <a href="./ttt-rmi.zip">código fonte da aplicação
    Jogo do Galo/Tic Tac Toe <img src="../_img/zip.png" alt="ZIP"></a> adaptada a este exercício.<br />
    </li>
    <ol type="1">
        <li>
        Veja como o programa está estruturado em três módulos: <i>server</i>, <i>client</i> e <i>interface</i>.<br />
		Cada módulo tem um POM próprio.
        </li>
        <li>
        Importe os projectos no Eclipse, recorrendo a <i> File &gt; Import &gt; Maven &gt; Existing Maven Projects</i>
        </li>
        <li>
        No ponto de partida, o código está todo centralizado no módulo <i>server</i>, estando o <i>client</i> vazio.
        <br />O módulo <i>interface</i> será usado num próximo passo.
        </li>
        <li>Estude os principais ficheiros com a implementação do jogo 
        (<tt>Game.java</tt> e <tt>TTT.java</tt> do módulo <i>server</i>).
        <ol type="a">
            <li>
            Repare que alguns métodos já são <a href="../01-tools/java-synch/index.html">sincronizados</a>.
            </li>
            <li>
            Porque é que esta sincronização é necessária?
            </li>
        </ol>
        </li>
        <li>
        Compile e experimente o jogo na sua versão centralizada 
        (executando <kbd>mvn compile exec:java</kbd>).<br />
		<br />
        </li>
    </ol>
    
    <li>
    Pretende-se que a classe <tt>TTT.java</tt>, que implementa o jogo, 
    passe a ser invocável remotamente.<br /> 
    Dessa forma, permitir-se-á que haja um cliente remoto
    que interage com os jogadores invocando os métodos do servidor via
    Java RMI (<i>Remote Method Invocation</i>).<br />
    Naturalmente, o cliente poderá correr numa máquina diferente da máquina que serve o jogo.
    </li>
    <ol type="1">
        <li>
        Comece por desenhar os métodos remotos do servidor numa interface chamada <tt>TTTService</tt>.<br />
        A interface deve expor todas as funções remotas que o cliente precisa de invocar,
		ou seja, <tt>play</tt>, <tt>checkWinner</tt> e <tt>currentBoard</tt>.<br />
		<br />
        Para ser uma interface remota, precisa de herdar de <tt>java.rmi.Remote</tt> e
        cada um dos seus métodos deve lançar uma <tt>java.rmi.RemoteException</tt>.<br />
        Consulte o <a href="./ShapeList.java">exemplo de interface remota apresentado no livro</a> para referência.<br />
		<br />
        </li>
        <ol type="a">
            <li>
            Coloque a nova interface no módulo <i>interface</i> (ficheiro <tt>TTTService.java</tt>).
            </li>
            <li>
            Depois de codificar a interface,
            compile o código e instale o módulo no seu repositório local:<br />
            <kbd>cd interface</kbd><br />
            <kbd>mvn install</kbd><br />
            </li>
            <li>
            Adicione a dependência no <tt>pom.xml</tt> do servidor e do cliente,
            pois esta interface terá de ser partilhada por ambos:
<pre class="prettyprint lang-xml">
    ...
        &lt;dependency&gt;
            &lt;groupId&gt;example&lt;/groupId&gt;
            &lt;artifactId&gt;ttt-rmi-interface&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    ...
</pre>
            </li>
            <li>
            Depois de editar os <tt>pom.xml</tt>, refresque as dependências do Maven no projeto Eclipse:<br />
            <tt><i>right-click</i> &gt; Maven &gt; Update Project... &gt; Force Update of Snapshots/Releases &gt; OK</tt><br />
			<br />
            </li>
        </ol>
        <li>
        No servidor, transforme a classe <tt>TTT</tt> para que passe a
        implementar a interface remota <tt>TTTService</tt> criada anteriormente.
        <ol type="a">
            <li>
            Para que as instâncias desta classe possam ser objetos remotos,
            modifique a definição da classe <tt>TTT</tt> de forma a herdar de
            <tt>java.rmi.server.UnicastRemoteObject</tt>
            e acrescente um construtor que lance excepção <tt>RemoteException</tt>.
            </li>
            <li>
            Esta classe deverá implementar a lógica dos métodos que o cliente irá chamar posteriormente, tal como definidos na interface <tt>TTTService</tt>.<br />
            Consulte o <a href="./ShapeListServant.java">exemplo da classe
            shapeListServant apresentado no livro</a> para referência.<br />
			<br />
            </li>
        </ol>
        </li>
        <li>
        No servidor, crie uma nova classe <tt>TTTServer</tt> que implementa a função <tt>main</tt> e
        onde correrá o servidor.<br />
        Na função <tt>main</tt> deverá:
        </li>
        <ol type="a">
            <li>
            Instanciar um objeto remoto do tipo <tt>TTT</tt>.
            </li>
            <li>
            Lançar um <tt>rmiregistry</tt> (serviço de nomes do RMI) e
            registar o objeto remoto nesse <tt>rmiregistry</tt> utilizando a classe <a href="https://docs.oracle.com/javase/8/docs/api/java/rmi/registry/LocateRegistry.html">java.rmi.registry.LocateRegistry</a>.
            </li>
			<li>
			Atualize a <tt>mainclass</tt> definida no <tt>pom.xml</tt> para refletir a classe que possui o método <tt>main</tt>.
			</li>
        </ol>
        Consulte o <a href="./ShapeListServer.java">exemplo da classe
        ShapeListServer apresentado no livro</a> para referência.<br />
		<br />
        <li>
        Deverá agora proceder à modificação do cliente de forma a chamar remotamente os métodos definidos anteriormente na interface <tt>TTTService</tt>.
        </li>
        <ol type="a">
            <li>
            Mova a classe <tt>ttt.Game</tt> do servidor para o cliente.
            Implemente um cliente remoto que, 
            com base nos comandos recebidos pela consola local, 
            invoca métodos do jogo remoto.<br />
            Assuma que ambos os jogadores de cada jogo usam o mesmo cliente.<br />
            Consulte o <a href="./ShapeListClient.java">exemplo do cliente
            apresentado no livro</a> para referência.<br />
			<br />
            </li>
            <li>
            Não se esqueça de, na chamada ao método <tt>Naming.lookup</tt>,
            definir correctamente o URL que localiza o objeto, na forma: 
            <tt>//host:port/name</tt>,
            em que <tt>host</tt> e <tt>port</tt> definem a máquina e o porto
            onde corre o <tt>rmiregistry</tt> onde foi
            registado o objeto remoto e <tt>name</tt> é o nome que foi
            atribuído ao objeto pelo servidor quando chamou <tt>rebind</tt>.
            </li>
            <li>
            Adicione o tratamento adequado às <a href="../01-tools/exceptions/index.html">exceções</a> lançadas quando acontece
            algo inesperado numa invocação remota. <br />
			As exceções de comunicação e tratamento de dados que podem ocorrer são todas subclasses de <tt>java.rmi.RemoteException</tt>. Exemplos:
            <ul>
                <li><tt>java.rmi.UnknownHostException</tt></li>
                <li><tt>java.rmi.ConnectException</tt></li>
                <li><tt>java.rmi.UnmarshalException</tt></li>
                <li><tt>java.rmi.MarshalException</tt></li>
            </ul>
            </li>
        </ol>
    </ol>

    <!--li>
    No terminal execute o comando <tt>rmiregistry &</tt>
    a partir da directoria onde se encontram as classes compiladas.
    </li-->

	<br />

    <li>
    Experimente lançar o servidor e depois um cliente para jogar.
    </li>

	<br />

    <li>
    Responda à seguinte questão:
    </li>
    <ol type="1">
        <li>
        Das classes e interfaces Java que utilizou, 
        quais são as que pertencem apenas ao cliente, apenas ao servidor e
        a ambos?
        </li>
    </ol>
</ol>

<br />

<p>
O resto do enunciado será entregue na aula. 
O objectivo será estender a solução resultante do enunciado acima com mais
procedimentos ou modificar alguns dos seus procedimentos actuais.
</p>

<p>&nbsp;</p>
</div>

<div class="objectivos">
<h2>Entrega da solução</h2>

<p>
    Fénix, Avaliação, Projetos, <b>mini Exercício 1 - Java RMI</b>
</p>

<p>
    A solução completa deverá ser submetida no Fénix 
    <b>antes do fim da sua aula de laboratório</b>.<br /> 
    Trabalhos submetidos depois da hora de fim da aula não serão considerados.<br>
</p>

<p>
    <b>Ter atenção ao seguinte:</b>
</p>
<ul>
    <li>Só são aceites trabalhos de estudantes que estiveram
        presentes no laboratório.</li>
    <!--li>Deverá incluir um ficheiro <tt>respostas.txt</tt> com as
        respostas às perguntas do enunciado do exercício.
    </li-->
    <li>Deverá também incluir um ficheiro <tt>README</tt>
        com resumo da funcionalidade implementada e com instruções para
        colocar o programa a funcionar como esperado.<br /> Por exemplo:
    </li>
    <ul>
        <li>A funcionalidade pedida foi total/parcialmente implementada
            <b>...</b>
        </li>
        <li>O servidor deve executar com o seguinte comando:<br />
        <tt>mvn install exec:java</tt>
        </li>
        <li>O cliente deve executar com o comando:<br />
        <tt>mvn compile exec:java</tt>
        </li>
    </ul>
    <li>Assegure-se que a solução é enviada em formato ZIP e que não
        contém código compilado (faça <tt>mvn clean</tt> antes de
        comprimir).
    </li>
</ul>
</div>

<p></p>

<div class="caixadestaque">
<h2>Como seria um projecto Java RMI mais elaborado?</h2>
<p>O projecto desenvolvido ao longo das alíneas apresentadas faz
    algumas simplificações importantes que normalmente não se observam
    num projecto real de Java RMI. Entre elas:
<ol>
    <li><i>Existe apenas uma instância de objeto remoto.</i><br />
        Normalmente pode existir um número variado de interfaces e classes
        remotas, assim como de suas instâncias.
    </li>
    <li><i>Há um processo que aloja o objeto remoto e outro processo
        que obtém referência remota para essa objeto, numa clara distinção
    entre servidor e cliente.</i><br /> 
        Na prática, um processo pode
        simultaneamente ser servidor de alguns objetos remotos e ter outras
        referências remotas (para objetos remotos noutros processos), sobre
        as quais invoca métodos (agindo também como cliente).
    </li>
    <li><i>No projecto acima nunca ocorre nenhuma situação de
    carregamento dinâmico de classes.</i> <br />
        Essa situação poderia, por exemplo, 
        acontecer se um método remoto recebesse ou retornasse um
        objeto por valor. Nesse caso seria necessário definir alguns
        aspectos de segurança da JVM (em particular, um Security Manager e
        uma Security Policy).
    </li>
    <li>
        <i>O RMIRegistry é lançado internamente pelo servidor na mesma JVM.</i><br /> 
        (<tt>LocateRegistry.createRegistry()</tt>). 
        O RMI Registry é normalmente um serviço autónomo que corre numa máquina virtual Java (JVM)
        separada do processo que instancia e solitica o registo de um objeto remoto.
        Neste caso, é necessário que os ficheiros com as interfaces remotas
        dos objetos a registar no Registry estejam disponíveis num URL definido
        no parâmetro "codebase" da JVM do processo servidor.
        Poderá descarregar e analisar um <a href="./hello-rmi.zip">exemplo que usa RMI Registry como serviço autónomo <img src="../_img/zip.png" alt="ZIP"></a>.
    </li>
</ol>

</div>

<hr />

<div class="rodape">
    <p>
        &copy; Docentes de Sistemas Distribu&iacute;dos, <a
            href="http://www.dei.tecnico.ulisboa.pt/">Dep. Eng. Informática</a>,
        <a href="http://www.ist.eu">Técnico Lisboa</a><br />
    </p>
</div>

</body>
</html>
